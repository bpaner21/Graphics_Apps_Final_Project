<html>
    <head>
        <title>Three.js Rubik Cube</title>

        <style>
            body {margin: 0;}
            canvas {width: 100%; height: 100%;}
        </style>
    </head>

    <body>
        <script src="js/three.js"></script>
        <script src="js/three.min.js"></script>
        <script src="js/SphereGeometry.js"></script>
        <script src="js/Tween.js"></script>
        <script src="js/dat.gui.js"></script>
        <script src="js/dat.gui.min.js"></script>


        <!-- Changed the input configuration for the mouse buttons on OrbitControls.js to enable rotation through the right mouse button instead of the left -->
        <!-- If possible, I'd like to alter this through my own function rather than through altering the source code of one of the libraries, but I don't know how at the moment -->
        <script src="js/OrbitControls_BJP_Custom.js"></script>


        <script>
            var rotateTrue = true;
            //rotateTrue = false;
            var sphereTrue = true;
            sphereTrue = false;

            var scene = new THREE.Scene();
            scene.background = new THREE.Color(0x494949);
            var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            var renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            window.addEventListener('resize', function () {
                var width = window.innerWidth;
                var height = window.innerHeight;
                renderer.setSize(width, height);
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
            })

            OrbitControl = new THREE.OrbitControls(camera, renderer.domElement);
            OrbitControl.enablePan = false;
            OrbitControl.enableZoom = false;
            OrbitControl.saveState();

            var subCubeSize = 2.85;
            // create a shape
            var geometry = new THREE.BoxGeometry(subCubeSize, subCubeSize, subCubeSize);

            var mouse = new THREE.Vector2();

            var cubeMaterials =
                [
                    new THREE.MeshPhongMaterial({ color: 0x008000, wireframe: false }),// , side: THREE.DoubleSide }), // Right - Green
                    new THREE.MeshPhongMaterial({ color: 0x0000FF, wireframe: false }),// , side: THREE.DoubleSide }), // Left - Blue
                    new THREE.MeshPhongMaterial({ color: 0xFF0000, wireframe: false }),// , side: THREE.DoubleSide }), // Top - Red
                    new THREE.MeshPhongMaterial({ color: 0xFFA500, wireframe: false }),// , side: THREE.DoubleSide }), // Bottom - Orange
                    new THREE.MeshPhongMaterial({ color: 0xFFFFFF, wireframe: false }),// , side: THREE.DoubleSide }), // Front - White
                    new THREE.MeshPhongMaterial({ color: 0xFFFF00, wireframe: false })// , side: THREE.DoubleSide }), // Back - Yellow
                    //new THREE.MeshPhongMaterial({color:0x202020, wireframe:false, side: THREE.DoubleSide}) // "Invisible" inner faces
                ];

            var setMaterials = function (x, y, z) {
                let blackMaterial = new THREE.MeshBasicMaterial({ color: 0x222222, wireframe: false, side: THREE.DoubleSide })
                let newMaterial =
                    [
                        new THREE.MeshPhongMaterial({ color: 0x008000, wireframe: false }),// , side: THREE.DoubleSide }), // Right - Green
                        new THREE.MeshPhongMaterial({ color: 0x0000FF, wireframe: false }),// , side: THREE.DoubleSide }), // Left - Blue
                        new THREE.MeshPhongMaterial({ color: 0xFF0000, wireframe: false }),// , side: THREE.DoubleSide }), // Top - Red
                        new THREE.MeshPhongMaterial({ color: 0xFFA500, wireframe: false }),// , side: THREE.DoubleSide }), // Bottom - Orange
                        new THREE.MeshPhongMaterial({ color: 0xFFFFFF, wireframe: false }),// , side: THREE.DoubleSide }), // Front - White
                        new THREE.MeshPhongMaterial({ color: 0xFFFF00, wireframe: false })// , side: THREE.DoubleSide }), // Back - Yellow
                        //new THREE.MeshPhongMaterial({color:0x202020, wireframe:false, side: THREE.DoubleSide}) // "Invisible" inner faces
                    ];

                if (x <= 0) {
                    newMaterial[0] = blackMaterial;
                }

                if (x >= 0) {
                    newMaterial[1] = blackMaterial;
                }

                if (y <= 0) {
                    newMaterial[2] = blackMaterial;
                }

                if (y >= 0) {
                    newMaterial[3] = blackMaterial;
                }

                if (z <= 0) {
                    newMaterial[4] = blackMaterial;
                }

                if (z >= 0) {
                    newMaterial[5] = blackMaterial;
                }

                return newMaterial;
            }

            var cube = new THREE.Object3D();
            var subCubes = [];
            var initialPosition = [];

            {
                let j = 0;
                for (let z = 3; z >= -3; z -= 3) {
                    for (let y = 3; y >= -3; y -= 3) {
                        for (let x = -3; x <= 3; x += 3) {
                            if (x == 0 && y == 0 && z == 0) {
                                continue;
                            }

                            let subMaterial = setMaterials(x, y, z);
                            subCubes[j] = new THREE.Mesh(geometry, subMaterial);

                            subCubes[j].position.set(x, y, z);
                            
                            //console.log("break");
                            //console.log("subCubes[" + j + "]:" + subCubes[j].position);
                            var geo = new THREE.EdgesGeometry(subCubes[j].geometry);
                            var mat = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 1 });
                            var wireframe = new THREE.LineSegments(geo, mat);
                            wireframe.renderOrder = 1; // make sure wireframes are rendered 2nd
                            subCubes[j].add(wireframe);
                            //scene.add(subCubes[j]);
                            cube.add(subCubes[j]);
                            initialPosition[j] = new THREE.Vector3 (x, y, z);
                            ++j;
                            //console.log(j);
                        }
                    }
                }
            }

            scene.add(cube);

            camera.position.z = 14;

            var ambientLight = new THREE.AmbientLight(0xFFFFFF, 0.8);
            scene.add(ambientLight);

            var directionalLight = new THREE.DirectionalLight(0x999999, 1);
            directionalLight.position.set(1000, 1000, 1000);
            scene.add(directionalLight);

            var spotLight = new THREE.SpotLight(0x999999, 0.7);
            spotLight.position.set(1000, 1000, 1000);
            //scene.add(spotLight);

            if (sphereTrue) {
                var sGeometry = new THREE.SphereGeometry(7.6, 25, 25);
                var sMaterial = new THREE.MeshBasicMaterial({ color: 0x111111, wireframe: true, side: THREE.DoubleSide })
                var sphere = new THREE.Mesh(sGeometry, sMaterial);
                scene.add(sphere);
            }

            function rotateX(_x) {
                for (let i = 0; i < subCubes.length; ++i) {
                    if (subCubes[i].position.x == _x) {

                        // Corners
                        if (subCubes[i].position.equals(new THREE.Vector3(_x, 3, -3))) {
                            subCubes[i].position.set(_x, 3, 3);
                        }
                        else if (subCubes[i].position.equals(new THREE.Vector3(_x, 3, 3))) {
                            subCubes[i].position.set(_x, -3, 3);
                        }
                        else if (subCubes[i].position.equals(new THREE.Vector3(_x, -3, 3))) {
                            subCubes[i].position.set(_x, -3, -3);
                        }
                        else if (subCubes[i].position.equals(new THREE.Vector3(_x, -3, -3))) {
                            subCubes[i].position.set(_x, 3, -3);
                        }

                        // Cross
                        else if (subCubes[i].position.equals(new THREE.Vector3(_x, 3, 0))) {
                            subCubes[i].position.set(_x, 0, 3);
                        }
                        else if (subCubes[i].position.equals(new THREE.Vector3(_x, 0, 3))) {
                            subCubes[i].position.set(_x, -3, 0);
                        }
                        else if (subCubes[i].position.equals(new THREE.Vector3(_x, -3, 0))) {
                            subCubes[i].position.set(_x, 0, -3);
                        }
                        else if (subCubes[i].position.equals(new THREE.Vector3(_x, 0, -3))) {
                            subCubes[i].position.set(_x, 3, 0);
                        }

                        subCubes[i].rotateOnWorldAxis(new THREE.Vector3(1, 0, 0), THREE.Math.degToRad(90));

                        /*console.log(i + ": (" +
                            subCubes[i].position.x + ", " + subCubes[i].position.y + ", " + subCubes[i].position.z + "), (" +
                            THREE.Math.radToDeg(subCubes[i].rotation.x) + ", " + THREE.Math.radToDeg(subCubes[i].rotation.y) + ", " + THREE.Math.radToDeg(subCubes[i].rotation.z) + ")");//*/
                    }
                }

                if (_x == -3) {
                    console.log('L');
                }
                else { // if (_x == 3) 
                    console.log('R');
                }
            }

            function rotateY(_y) {
                for (let i = 0; i < subCubes.length; ++i) {
                    if (subCubes[i].position.y == _y) {

                        // Corners
                        if (subCubes[i].position.equals(new THREE.Vector3(-3, _y, -3))) {
                            subCubes[i].position.set(3, _y, -3);
                        }
                        else if (subCubes[i].position.equals(new THREE.Vector3(3, _y, -3))) {
                            subCubes[i].position.set(3, _y, 3);
                        }
                        else if (subCubes[i].position.equals(new THREE.Vector3(3, _y, 3))) {
                            subCubes[i].position.set(-3, _y, 3);
                        }
                        else if (subCubes[i].position.equals(new THREE.Vector3(-3, _y, 3))) {
                            subCubes[i].position.set(-3, _y, -3);
                        }

                        // Cross
                        else if (subCubes[i].position.equals(new THREE.Vector3(0, _y, -3))) {
                            subCubes[i].position.set(3, _y, 0);
                        }
                        else if (subCubes[i].position.equals(new THREE.Vector3(3, _y, 0))) {
                            subCubes[i].position.set(0, _y, 3);
                        }
                        else if (subCubes[i].position.equals(new THREE.Vector3(0, _y, 3))) {
                            subCubes[i].position.set(-3, _y, 0);
                        }
                        else if (subCubes[i].position.equals(new THREE.Vector3(-3, _y, 0))) {
                            subCubes[i].position.set(0, _y, -3);
                        }

                        subCubes[i].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), THREE.Math.degToRad(-90));

                        /*console.log(i + ": (" +
                            subCubes[i].position.x + ", " + subCubes[i].position.y + ", " + subCubes[i].position.z + "), (" +
                            THREE.Math.radToDeg(subCubes[i].rotation.x) + ", " + THREE.Math.radToDeg(subCubes[i].rotation.y) + ", " + THREE.Math.radToDeg(subCubes[i].rotation.z) + ")");//*/
                    }
                }

                if (_y == -3) {
                    console.log('D');
                }
                else { // if (_y == 3) 
                    console.log('U');
                }
            }

            function rotateZ(_z) {
                for (let i = 0; i < subCubes.length; ++i) {
                    if (subCubes[i].position.z == _z) {

                        // Corners
                        if (subCubes[i].position.equals(new THREE.Vector3(-3, 3, _z))) {
                            subCubes[i].position.set(3, 3, _z);
                        }
                        else if (subCubes[i].position.equals(new THREE.Vector3(3, 3, _z))) {
                            subCubes[i].position.set(3, -3, _z);
                        }
                        else if (subCubes[i].position.equals(new THREE.Vector3(3, -3, _z))) {
                            subCubes[i].position.set(-3, -3, _z);
                        }
                        else if (subCubes[i].position.equals(new THREE.Vector3(-3, -3, _z))) {
                            subCubes[i].position.set(-3, 3, _z);
                        }

                        // Cross
                        else if (subCubes[i].position.equals(new THREE.Vector3(0, 3, _z))) {
                            subCubes[i].position.set(3, 0, _z);
                        }
                        else if (subCubes[i].position.equals(new THREE.Vector3(3, 0, _z))) {
                            subCubes[i].position.set(0, -3, _z);
                        }
                        else if (subCubes[i].position.equals(new THREE.Vector3(0, -3, _z))) {
                            subCubes[i].position.set(-3, 0, _z);
                        }
                        else if (subCubes[i].position.equals(new THREE.Vector3(-3, 0, _z))) {
                            subCubes[i].position.set(0, 3, _z);
                        }

                        subCubes[i].rotateOnWorldAxis(new THREE.Vector3(0, 0, 1), THREE.Math.degToRad(-90));

                        /*console.log(i + ": (" +
                            subCubes[i].position.x + ", " + subCubes[i].position.y + ", " + subCubes[i].position.z + "), (" +
                            THREE.Math.radToDeg(subCubes[i].rotation.x) + ", " + THREE.Math.radToDeg(subCubes[i].rotation.y) + ", " + THREE.Math.radToDeg(subCubes[i].rotation.z) + ")");//*/
                    }
                }

                if (_z == 3) {
                    console.log('F');
                }
                else { // if (_z == -3) 
                    console.log('B');
                }
            }

            var guiRight = new dat.GUI({ width: 100 });
            var guiLeft = new dat.GUI({ width: 130 });

            var rotate = new function () {
                this.L = function () {
                    rotateX(-3);
                };
                this.R = function () {
                    rotateX(3);
                }

                /*this.Li = function () {
                    rotateX_i(-3);
                }
                this.Ri = function () {
                    rotateX_i(3);
                }//*/

                this.U = function () {
                    rotateY(3);
                }
                this.D = function () {
                    rotateY(-3);
                }

                /*this.Ui = function () {
                    rotateY_i(3);
                }
                this.Di = function () {
                    rotateY_i(-3);
                }//*/

                this.F = function () {
                    rotateZ(3);
                }
                this.B = function () {
                    rotateZ(-3);
                }

                /*this.Fi = function () {
                    rotateZ_i(3);
                }
                this.B = function () {
                    rotateZ_i(-3);
                }//*/

                this.Reset = function () {
                    for (let i = 0; i < subCubes.length; ++i) {

                        subCubes[i].position.x = initialPosition[i].x;
                        subCubes[i].position.y = initialPosition[i].y;
                        subCubes[i].position.z = initialPosition[i].z;
                        subCubes[i].rotation.set(0, 0, 0);
                    }

                    //console.log("Reset Cubes");
                    //console.log("subCubes[0].position = (" + subCubes[0].position.x + ", " + subCubes[0].position.y + ", " + subCubes[0].position.z + ")");
                    //console.log("subCubes[0].rotation = (" + THREE.Math.radToDeg(subCubes[0].rotation.x) + ", " + THREE.Math.radToDeg(subCubes[0].rotation.y) + ", " + THREE.Math.radToDeg(subCubes[0].rotation.z) + ")");
                }

                this.Scramble = function () {
                    for (let i = 0; i < 20; ++i) {
                        let turn = Math.floor(Math.random() * 6);

                        switch (turn) {
                            case (0): {

                                rotateX(-3);
                                break;
                            }
                            case (1): {
                                rotateX(3);
                                break;
                            }
                            case (2): {

                                rotateY (-3);
                                break;
                            }
                            case (3): {
                                rotateY(3);
                                break;
                            }
                            case (4): {

                                rotateZ(-3);
                                break;
                            }
                            case (5): {
                                rotateZ(3);
                                break;
                            }
                        }
                    }
                }
            }

            guiLeft.add(rotate, 'L');
            guiRight.add(rotate, 'R');

            /*guiLeft.add(rotate, 'Li');
            guiRight.add(rotate, 'Ri');//*/

            guiLeft.add(rotate, 'U');
            guiRight.add(rotate, 'D');

            /*guiLeft.add(rotate, 'Ui');
            guiRight.add(rotate, 'Di');//*/

            guiLeft.add(rotate, 'F');
            guiRight.add(rotate, 'B');

            /*guiLeft.add(rotate, 'Fi');
            guiRight.add(rotate, 'Bi');//*/

            guiRight.add(rotate, 'Reset');
            guiLeft.add(rotate, 'Scramble');

            var updateRotation = function () {
                if (rotateTrue) {
                    let rotationX = 0.02;
                    let rotationY = 0.01;
                    let rotationZ = 0.00;

                    if (sphereTrue) {
                        sphere.rotation.x += rotationX;
                        sphere.rotation.y += rotationY;
                        sphere.rotation.z += rotationZ;
                    }

                    cube.rotation.x += rotationX;
                    cube.rotation.y += rotationY;
                    cube.rotation.z += rotationZ;
                }
            };

            // program logic
            var update = function () {
                //updateRotation();
            };

            // draw Scene
            var render = function () {
                renderer.render(scene, camera);
            };

            // run game loop (update, render, repeat)
            var GameLoop = function () {
                requestAnimationFrame(GameLoop);

                update();
                render();
            };


            GameLoop();

        </script>
    </body>
</html>
